    255       longjmp(*Top_jmp_buf, JMP_RESTORE);
    256     }
    257     else {
    258       STk_print(x, STk_curr_oport, WRT_MODE);
    259       Putc('\n', STk_stdout);
    260     }
    261   }
    262 }
    263 
    264 static void repl_driver(int argc, char **argv)
    265 {
    266   static int k;
    267   static char **new_argv;
    268   
    269   new_argv = STk_process_argc_argv(argc, argv);
    270 
    271   if (STk_arg_image) {
    272     STk_save_unix_args_and_environment(argc, argv);
    273     STk_restore_image(STk_arg_image);
    274   }
    275   else {
    276     /* Normal initialisation */
    277     STk_reset_eval_stack();
    278   }
    279 
    280   /* Point where we come back on errors, image restoration, ... */
    281   k = setjmp(*Top_jmp_buf);
    282   
    283   Error_context	     = ERR_OK;	
    284   STk_sigint_counter = 0;
    285   STk_control_C	     = 0;
    286 
    287   switch (k) {
    288     case 0:		init_interpreter();
    289 			STk_initialize_scheme_args(new_argv);
    290 			load_init_file();
    291 #ifdef USE_TK
    292 #  ifdef WIN32
    293 			if (!STk_arg_no_tk)
    294 			  Tk_main(STk_arg_sync,
    295 				  STk_arg_name,
    296 				  STk_arg_file,
    297 				  "localhost:0",
    298 				  STk_arg_geometry);
    299 #  else
    300 			if (!STk_arg_Xdisplay) 
    301 			  STk_arg_Xdisplay =  getenv("DISPLAY");
    302 			if (!STk_arg_no_tk && STk_arg_Xdisplay)
    303 			  Tk_main(STk_arg_sync,
    304 				  STk_arg_name,
    305 				  STk_arg_file,
    306 				  STk_arg_Xdisplay,
    307 				  STk_arg_geometry);
    308 #  endif
    309 #endif
    310 			finish_initialisation();
    311 			break;
    312     case JMP_RESTORE:	STk_restore_unix_args_and_environment(&argc, &argv);
    313 			/* Process another time args since we have lost them ! */
    314 			new_argv = STk_process_argc_argv(argc, argv);
    315 			STk_initialize_scheme_args(new_argv);
    316 #ifdef USE_TK
    317 			if (!STk_arg_no_tk && (STk_arg_Xdisplay||getenv("DISPLAY")))
    318 			  Tk_main(STk_arg_sync, 
    319 				  STk_arg_name, 
    320 				  STk_arg_file, 
    321 				  STk_arg_Xdisplay,
    322 				  STk_arg_geometry);
    323 #endif
    324 			finish_initialisation();
    325 			break;
    326     case JMP_THROW:
    327     case JMP_ERROR:	break;
    328   }
    329 
    330   repl_loop();
    331   if (STk_interactivep) fprintf(STk_stderr, "Bye.\n");
    332   STk_quit_interpreter(UNBOUND);
    333 }
    334 
    335 /******************************************************************************
    336  *
    337  * Toplevel
    338  * 
    339  ******************************************************************************/
    340 
    341 void STk_toplevel(int argc, char **argv)
    342 {
    343   SCM stack_start; /* Unused variable. Its the first stack allocated variable */
    344 
run -visual staticgray
break Tk_main
run -visual staticgray
next
step
next
break tkFrame.c:297
cont
print screenName
next
print className
next
print visualName
next
step
graph display dictPtr
next
print visInfoList
next
print new
next
run
up
down
run
cont
next
break main
break tclUnixNotfy.c:248
cont
quit
run -f T
up
run -f T
1&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
run -f T
qqqqq
break STk_read_line
break apply_read_closure 
run -f T
quit
run
run -f T
break STk_read_line
break apply_read_closure 
run -f T
graph display port
next
step
next
step
next
run
all of the
    517 	 * event sources to give them a chance to setup for the wait.
    518 	 */
    519 
    520 	blockTimeSet = 0;
    521 	for (sourcePtr = tclFirstEventSourcePtr; sourcePtr != NULL;
    522 		sourcePtr = sourcePtr->nextPtr) {
    523 	    (*sourcePtr->setupProc)(sourcePtr->clientData, flags);
    524 	}
    525 	if ((flags & TCL_DONT_WAIT) ||
    526 		((flags & TCL_IDLE_EVENTS) && TclIdlePending())) {
    527 	    /*
    528 	     * Don't block:  there are idle events waiting, or we don't
    529 	     * care about idle events anyway, or the caller asked us not
    530 	     * to block.
    531 	     */
    532 
    533 	    blockTime.sec = 0;
    534 	    blockTime.usec = 0;
    535 	    timePtr = &blockTime;
    536 	} else if (blockTimeSet) {
    537 	    timePtr = &blockTime;
    538 	} else {
    539 	    timePtr = NULL;
    540 	}
    541 
    542 	/*
    543 	 * Wait until an event occurs or the timer expires.
    544 	 */
    545 
    546 	if (Tcl_WaitForEvent(timePtr) == TCL_ERROR) {
    547 	    return 0;
    548 	}
    549 
    550 	/*
    551 	 * Give each of the event sources a chance to queue events,
    552 	 * then call ServiceEvent and give it another chance to
    553 	 * service events.
    554 	 */
    555 
    556 	for (sourcePtr = tclFirstEventSourcePtr; sourcePtr != NULL;
    557 		sourcePtr = sourcePtr->nextPtr) {
    558 	    (*sourcePtr->checkProc)(sourcePtr->clientData, flags);
    559 	}
un -f T
run -f T
next
step
next
cont
quit
run -f T < T.stk
up
quit
run
break finish_initialisation
run
next
break toplevel.c:201
run -f T < T.stk
cont
step
next
up
down
break io.c:74
run -f T < T.stk
disable 1
disable 2
quit
run
quit
break Tcl_DeleteInterp
run
bt
next
step
next
cont
next
n
s
step
next
quit
break main
break Tk_DestroyWindow
run
disable 1
cont
next
cont
next
cont
step
stepi
next
run
info line 'Tk_DestroyWindow'
break tkWindow.c:1145
cont
disable 2
cont
next
step
next
tbreak tclHash.c:190
cont
next
run
cont
quit

